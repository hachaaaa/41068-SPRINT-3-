import cv2
import numpy as np

# Load library turtle ground truth map generated by GitHub
gazebo_map_path = "/home/student/map.png"
gazebo_map = cv2.imread(gazebo_map_path, cv2.IMREAD_COLOR)

# Load the generated SLAM map
slam_map_path = "/home/student/ros2_ws/src/sprint3/maps/my_map.pgm"
slam_map = cv2.imread(slam_map_path, cv2.IMREAD_COLOR)

# Scaling factor to resize the SLAM map
scaling_factor = 0.8  # change value to change size in x direction
# Stretch factor for the y-axis 
y_stretch_factor = 1.9  # greater than 1 to stretch, less than 1 to compress

# Calculate new dimensions for the SLAM map
new_width = int(gazebo_map.shape[1] * scaling_factor)
new_height = int(gazebo_map.shape[0] * scaling_factor * y_stretch_factor)

 # Adjust offsets to center the resized SLAM map on the Gazebo map
x_offset = (gazebo_map.shape[1] - new_width) // 2 + 80 # move image to right for better lineup  
y_offset = (gazebo_map.shape[0] - new_height) // 2

# Ensure the offsets and dimensions are within valid range
# accounts for if slam map is bigger than gazebo map
if x_offset < 0:
    x_offset = 0
    new_width = gazebo_map.shape[1]

if y_offset < 0:
    y_offset = 0
    new_height = gazebo_map.shape[0]

# Resize the SLAM map to the final dimensions
resized_slam_map = cv2.resize(slam_map, (new_width, new_height))

# Create a blank canvas with the same size as the Gazebo map
canvas = np.zeros_like(gazebo_map)

# Place the resized SLAM map onto the canvas
canvas[y_offset:y_offset + new_height, x_offset:x_offset + new_width] = resized_slam_map

# Overlay the SLAM map onto the Gazebo map with some transparency
overlay = cv2.addWeighted(gazebo_map, 0.7, canvas, 0.3, 0)  # Adjust weights for transparency

# Show the overlaid image
cv2.imshow('Overlay', overlay)
cv2.waitKey(0)  # Press any key to close the window
cv2.destroyAllWindows()

# Save the overlaid image
output_path = "/home/student/ros2_ws/src/sprint3/maps/overlay.png"
cv2.imwrite(output_path, overlay)
